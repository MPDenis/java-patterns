package com.paterns.strustural.proxy.refactoring_guru_example;

public class Main {

    /**
     *        ------------  PROXY -------------
     * Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс,
     * что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал
     * экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.
     */

    /**
     *       -------------- Применимость ------------
     *
     * - Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект,
     * грузящий данные из файловой системы или базы данных.
     *
     * - Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей,
     * и вам хочется защищать объект от неавторизованного доступа.
     *
     * - Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.
     *  В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.
     *
     * - Логирование запросов, Кэширование запросов.
     */

    /**
     *       ---------- Шаги реализации -------------
     *
     * - Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
     *
     * - Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект
     * создаётся самим заместителем. В редких случаях заместитель получает
     * готовый сервисный объект от клиента через конструктор.
     *
     * - Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то
     * полезную работу, методы заместителя должны передать запрос сервисному объекту.
     *
     * - Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный
     * сервисный объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
     *
     * - Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении
     * клиента к методам заместителя.
     *
     *
     */

    /**
     *  --------------- Различия и сходства ЗАМЕСТИТЕЛЯ И ДЕКОРАТОРА  -----------------
     *
     *  - Декоратор предоставляет расширенный интерфейс. Заместитель предоставляет тот же интерфейс.
     *
     *  - Декоратор и Заместитель имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены
     *   на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем,
     *   что Заместитель сам управляет жизнью сервисного объекта, а обёртывание Декораторов контролируется клиентом.
     * @param args
     */


    public static void main(String[] args) {
        YouTubeDownloader naiveDownloader = new YouTubeDownloader(new ThirdPartyYouTubeClass());
        YouTubeDownloader smartDownloader = new YouTubeDownloader(new YouTubeCacheProxy());

        long naive = test(naiveDownloader);
        long smart = test(smartDownloader);
        System.out.print("Time saved by caching proxy: " + (naive - smart) + "ms");

    }

    private static long test(YouTubeDownloader downloader) {
        long startTime = System.currentTimeMillis();

        // User behavior in our app:
        downloader.renderPopularVideos();
        downloader.renderVideoPage("catzzzzzzzzz");
        downloader.renderPopularVideos();
        downloader.renderVideoPage("dancesvideoo");
        // Users might visit the same page quite often.
        downloader.renderVideoPage("catzzzzzzzzz");
        downloader.renderVideoPage("someothervid");

        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.print("Time elapsed: " + estimatedTime + "ms\n");
        return estimatedTime;
    }
}
